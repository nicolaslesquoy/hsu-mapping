*.bak
result*.json
figures/
images/
a_mesh/
b_mesh/
precice*/
out/
mapped/
input_mesh.vtu
result*.vtu
*.pdf
archives/
*.log
checks/
*.vtk
blade/
input.vtu
*.png
input_modified.vtu
export/
config.json
*.tar.gz
meshes/
*.vtu
.ruff_cache
stretched/
test/
*.slurm
__pycache__/
*.pyc
*.xml
cfd-data/
*.csv
*.out
bin/
obj/
.vscode/
*.toml


if __name__ == "__main__":
    main(folder_name="test_rastrigin_mod")
    folder_name = "test"
    input_mesh = "0_0005.vtk"
    mapping_methods = [
        "nearest-neighbor",
        "nearest-projection",
        "nearest-neighbor-gradient",
        "rbf/compact-polynomial-c0",
        "rbf/compact-polynomial-c2",
        "rbf/compact-polynomial-c4",
        "rbf/compact-polynomial-c6",
        "rbf/compact-polynomial-c8",
        "rbf/compact-tps-c2",
        "rbf/multiquadrics",
        "rbf/inverse-multiquadrics",
        "rbf/gaussian",
        "rbf/volume-splines",
        "rbf/thin-plate-splines"
    ]
    output_meshes = list(PATH_TO_MESHES.glob("*.vtk"))
    # output_meshes = [
    #     "0_01.vtk",
    #     "0_001.vtk",
    #     "0_004.vtk",
    #     "0_009.vtk",
    #     "0_0007.vtk"
    # ]
    nb_vertex = 10
    config_data = {
        "input-mesh": str(input_mesh),
        "output-mesh": None,
        "test-function": "rastrigin_mod",
        "mapping-method": None,
        "additional-config": {
            "basis-function": None,
            "support-radius": None,
            "shape-parameter": None,
        },
        "nb-procs": 8,
    }
    safety_coef = 0.6
    results = {f"{method}": [] for method in mapping_methods}
    for method in mapping_methods:
        config_data["mapping-method"] = "rbf-pum-direct" if "rbf" in method else method
        for mesh in output_meshes:
            h = float(str(mesh.name).split(".")[0].replace("_","."))
            if "rbf" in method and method.split("/")[1] not in ["gaussian"]:
                config_data["additional-config"]["basis-function"] = method.split("/")[1]
                config_data["additional-config"]["support-radius"] = nb_vertex * h * safety_coef
                config_data["additional-config"]["shape-parameter"] = nb_vertex * h * safety_coef
            elif "rbf" in method and method.split("/")[1] in ["gaussian"]:
                config_data["additional-config"]["basis-function"] = method.split("/")[1]
                config_data["additional-config"]["support-radius"] = np.nan
                config_data["additional-config"]["shape-parameter"] = nb_vertex * h * safety_coef
            else:
                config_data["additional-config"]["basis-function"] = None
                config_data["additional-config"]["support-radius"] = nb_vertex * h * safety_coef
                config_data["additional-config"]["shape-parameter"] = nb_vertex * h * safety_coef
            # get file name with extension
            config_data["output-mesh"] = str(mesh.name)
            config_file = pathlib.Path(f"config.json")
            with open(config_file, "w") as f:
                json.dump(config_data, f, indent=2)
            try:
                main(folder_name=folder_name)
                # open stats.json
                with open(
                    PATH_TO_OUT / folder_name / "stats.json", "r"
                ) as f:
                    data = json.load(f)
                rmse = data["relative-l2"]
                linfty = data["abs_max"]
                results[method].append((h, rmse, linfty))
            except Exception as e:
                print(
                    f"Error occurred for {method} with mesh {mesh}: {e}. Skipping this case."
                )
                results[method].append((h, -1, -1))
                continue
    # Save results to a CSV file
    results_file = "results.csv"
    with open(results_file, "w") as f:
        f.write("Method,Mesh Size,RMSE,L_infty\n")
        for method, values in results.items():
            for h, rmse, linfty in values:
                f.write(f"{method},{h},{rmse},{linfty}\n")
    # with open("results.csv", "r") as f:
    #     lines = f.readlines()
    # results = {}
    # for line in lines[1:]:
    #     method, h, rmse, linfty = line.strip().split(",")
    #     if method not in results:
    #         results[method] = []
    #     results[method].append((float(h), float(rmse), float(linfty)))
    # # Plot the errors
    # for method, values in results.items():
    #     sizes = [v[0] for v in values]
    #     rmses = [v[1] for v in values]
    #     linfties = [v[2] for v in values]
    #     # Remove all occurrences of -1
    #     sizes = [s for s, r in zip(sizes, rmses) if r != -1]
    #     rmses = [r for r in rmses if r != -1]
    #     linfties = [l for l in linfties if l != -1]
    #     plt.scatter(sizes, rmses, label=f"{method} RMSE")
    #     # plt.plot(sizes, linfties, label=f"{method} Linfty", linestyle="--")
    # plt.xscale("log")
    # plt.yscale("log")
    # plt.savefig("error_analysis.png", dpi=300, bbox_inches="tight")
